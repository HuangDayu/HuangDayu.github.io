---
title: 关于灵活架构的思考
date: 2021-03-12
categories: 
- 研讨技术
layout: post
comments: true
published: true
permalink: /blog/49
---

## 前言

---

&emsp;&emsp;由于项目的需要，架构必须适应于不同资源，环境下的灵活部署，不同框架，中间件，组件下灵活适配。在实践过程中得出此篇文章。  

<!-- more -->

## 灵活架构的定义

---

&emsp;&emsp;架构，在物理模式上，分为集群模式和单机模式；在软件模式上，分为单体模式和分布式模式。很显然，所谓灵活，就是架构要通过高度自定义配置，灵活选择物理模式和软件模式。这种架构设计模式，对于小企业，小团队，简直就是架构的最理想状态。

&emsp;&emsp;在我看来，灵活的架构由项目结构，动态配置，组件隔离3个部分组成，且看我娓娓道来。

## 灵活的项目结构

---

&emsp;&emsp;灵活架构往往是从灵活的项目结构开始的。我认为项目结构的设计是开发者能力的一种体现，而且是最直接的体现。优秀的项目结构，能够让阅读者能够从中一眼看出架构设计。项目结构的设计一般有按技术、业务、应用、产品几种层次来设计。然而，如果只按这一种方式来设计结构，明显不合理，也不灵活。所以，项目应当是多种层次结合，由浅入深，循序渐进。以下是本人的一次**`AI-IOT`**项目按照领域驱动设计规范（`DDD`）设计项目结构的实践：  

```shell
.
├── ai-iot-app																	应用层（前台）
│   ├── ai-iot-app-monolith-boot												单体应用
│   ├── ai-iot-app-auth															授权认证应用
│   ├── ai-iot-app-open															对外开放应用
│   ├── ai-iot-app-platform-admin												平台管理应用
│   ├── ai-iot-app-smart-city													智慧城市应用
│   ├── ai-iot-app-smart-community												智慧社区应用
│   ├── ai-iot-app-smart-home													智慧家庭应用
│   └── ai-iot-app-tenantry-admin												租户管理应用
│       ├── ai-iot-app-tenantry-admin-boot										SpringBootApplication模块
│       ├── ai-iot-app-tenantry-admin-business									业务模块
│       └── ai-iot-app-tenantry-admin-controller								控制层模块
├── ai-iot-base																	基础层
│   ├── ai-iot-base-etcd														ETCD公共接口模块
│   ├── ai-iot-base-kafka														卡夫卡公共接口模块
│   ├── ai-iot-base-mongodb														MongoDB公共接口模块
│   ├── ai-iot-base-mysql														MySQL公共接口模块，如通用Mapper
│   └── ai-iot-base-redis														Redis公共接口模块
├── ai-iot-common																公共模块
│   ├── ai-iot-common-annotation												公共注解
│   ├── ai-iot-common-dto														公共数据模型
├── ai-iot-domain																领域层（中台）
│   ├── ai-iot-domain-account													账户领域服务
│   ├── ai-iot-domain-base														基础领域服务
│   ├── ai-iot-domain-device													设备领域服务
│   └── ai-iot-domain-rule														规则引擎领域服务
│       ├── ai-iot-domain-rule-adapter											基础层适配器模块
│       ├── ai-iot-domain-rule-boot												SpringBootApplication模块
│       ├── ai-iot-domain-rule-common											公共模块
│       ├── ai-iot-domain-rule-core												业务实现模块
│       └── ai-iot-domain-rule-service											业务接口模块
└── ai-iot-gateway																网关层（接入层）
    ├── ai-iot-gateway-api														http网关
    └── ai-iot-gateway-mqtt														mqtt网关
        ├── ai-iot-gateway-mqtt-adapter											基础层适配器模块
        ├── ai-iot-gateway-mqtt-boot											SpringBootApplication模块
        ├── ai-iot-gateway-mqtt-common											公共模块
        ├── ai-iot-gateway-mqtt-core											核心层模块
        └── ai-iot-gateway-mqtt-service										 	业务接口模块
```

&emsp;&emsp;以上项目结构大致分为网关层、前台应用层、领域服务层和基础服务接口层，然后每一层又分为多个模块，大致有控制层模块、业务接口模块、业务核心模块、公共模块，应用启动模块。其中，值得注意的是，每一个项目有一个**`**-boot`**的模块，顾名思义，就是`SpringBootApplication`的启动模块，`ai-iot-app-monolith-boot`模块是将整个项目打包成单体应用的模块。  

&emsp;&emsp;这样的项目架构，一次打包就可以打包成单体和分布式两种项目，如果想要分布式，则分别启动每个项目的**`**-boot`**模块，即可作为`SpringCloud`微服务部署，如果想要单体，则只需将每一个`domain`项目的`core`模块和`service`模块，将每一个`app`项目的`controller`模块依赖到`ai-iot-app-monolith-boot`项目，即可作为单体项目部署。注意，在扫描包时，注意不要扫描非必要包，要精准扫描，避免注入非必要的`bean`。  


## 灵活的架构配置

---

&emsp;&emsp;配置，是软件设计领域的必备灵丹妙药，在无需修改任何代码的情况下，就可以让软件架构，软件能力按照需求快速上阵，何乐而不为呢？

&emsp;&emsp;在微服务被推上架构设计神坛的当下，`SpringCloud`成为`java`领域微服务的事实标准。所以`SpringBoot`的**条件装配**（[`@Conditional`](/blog/24#springboot-注解)）将成为此段章节的主角。比如，在此项目中，我将服务是单体模式还是微服务模式，通过配置文件与条件装配结合的方式来灵活注入接口的`bean`，甚至抽象出多个自定义重复注解，以便在开发过程中方便理解和使用。

```java
/**
 * 单体组件
 *
 * @author huangdayu create at 2021/3/8 15:19
 */
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ConditionalOnExpression("'true'.equals('${ai-iot.monolith:false}')")
@Component
public @interface MonolithComponent {


    @AliasFor(annotation = Component.class)
    String value() default "";

}
```

```java
/**
 * 微服务接口
 *
 * @author huangdayu create at 2021/3/8 15:24
 */
@Retention(RetentionPolicy.RUNTIME)
@Documented
@FeignClient
public @interface MicroserviceService {

    @AliasFor(annotation = FeignClient.class)
    java.lang.String value() default "";

    @java.lang.Deprecated
    @AliasFor(annotation = FeignClient.class)
    java.lang.String serviceId() default "";

    @AliasFor(annotation = FeignClient.class)
    java.lang.String contextId() default "";

    @AliasFor(annotation = FeignClient.class)
    java.lang.String name() default "";

    @AliasFor(annotation = FeignClient.class)
    java.lang.String qualifier() default "";

    @AliasFor(annotation = FeignClient.class)
    java.lang.String url() default "";

    @AliasFor(annotation = FeignClient.class)
    boolean decode404() default false;

    @AliasFor(annotation = FeignClient.class)
    java.lang.Class<?>[] configuration() default {};

    @AliasFor(annotation = FeignClient.class)
    java.lang.Class<?> fallback() default void.class;

    @AliasFor(annotation = FeignClient.class)
    java.lang.Class<?> fallbackFactory() default void.class;

    @AliasFor(annotation = FeignClient.class)
    java.lang.String path() default "";

    @AliasFor(annotation = FeignClient.class)
    boolean primary() default true;

}
```

```java
/**
 * 微服务熔断组件
 *
 * @author huangdayu create at 2021/3/8 15:24
 */
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ConditionalOnExpression("'false'.equals('${ai-iot.monolith:false}')")
@Component
public @interface MicroserviceFallback {

    @AliasFor(annotation = Component.class)
    String value() default "";

}
```

```java
/**
 * 微服务接口实现组件
 *
 * @author huangdayu create at 2021/3/8 15:24
 */
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ConditionalOnExpression("'false'.equals('${ai-iot.monolith:false}')")
@Primary // 多例时，首选该bean，因为 fallback bean 也存在容器中
@RestController
@RequestMapping
public @interface MicroserviceComponent {

    @AliasFor(annotation = RequestMapping.class)
    String name() default "";

    @AliasFor(annotation = RequestMapping.class)
    String path() default "";

    @AliasFor(annotation = RequestMapping.class)
    RequestMethod[] method() default {};

    @AliasFor(annotation = RequestMapping.class)
    String[] params() default {};

    @AliasFor(annotation = RequestMapping.class)
    String[] headers() default {};

    @AliasFor(annotation = RequestMapping.class)
    String[] consumes() default {};

    @AliasFor(annotation = RequestMapping.class)
    String[] produces() default {};
}
```

```java
/**
 * 查询设备信息接口
 *
 * @author huangdayu create at 2021/3/8 10:51
 */
@MicroserviceService(name = "ai-iot-domain-device-boot",
        contextId = "ai-iot-domain-device-boot-deviceDetailsService",
        path = "/deviceDetailsService",
        fallback = DeviceDetailsService.DeviceDetailsServiceFallbackImpl.class
)
public interface DeviceDetailsService {


    @GetMapping("/getDeviceDetails/{id}")
    DeviceDetailsDTO getDeviceDetails(@PathVariable(name = "id") Long id);

    @MicroserviceFallback
    class DeviceDetailsServiceFallbackImpl implements DeviceDetailsService {

        @Override
        public DeviceDetailsDTO getDeviceDetails(Long id) {
            return null;
        }

    }

}
```

```java
/**
 * 查询设备信息接口的实现（单体模式注入）
 *
 * @author huangdayu create at 2021/3/8 17:53
 */
@MonolithComponent
public class DeviceDetailsServiceImpl implements DeviceDetailsService {

    /**
     * 查询设备信息接口的实现（微服务模式注入）
     */
    @MicroserviceComponent(path = "/deviceDetailsService")
    public static class DeviceDetailsServiceRpcImpl extends DeviceDetailsServiceImpl implements DeviceDetailsService {

    }

    @Autowired
    private ProductDetailsService productDetailsService;


    @Override
    public DeviceDetailsDTO getDeviceDetails(Long id) {
        return new DeviceDetailsDTO(id, "deviceName_" + id, productDetailsService.getProductDetails(id));
    }


}
```


&emsp;&emsp;如果读者有一定的`SpringCloud`开发经验，则一眼看出此番操作的精髓：抽象一个接口，只有一个真正的业务实现，通过读取模式配置，注入不同的`bean`，以实现单体下调用本地接口，在微服务下，调用远程接口，也达到了资源的最优利用。

## 灵活的组件隔离

---

&emsp;&emsp;开源框架、组件、中间件是每一个项目都逃不过的技术话题。也总所周知，软件世界是千变万化的，今天还热门的框架也许明天就淘汰了，今天还持续维护的项目也许明天就停止维护了，所以，以不变应万变才是永恒的真理。无论是外部存储，还是消息中间件，都在其框架和核心业务之间抽象一层接口，以实现对框架和中间件的无缝切换，核心业务不需要做任何的修改，如果时间允许，还可以做成灵活配置的形式。  

&emsp;&emsp;所以，才在上述项目中设计了`adapter`模块。

## 总结

&emsp;&emsp;之前，我觉得架构应该是实用型的，而今，我觉得还有在前面加上灵活型。  

&emsp;&emsp;总之，一句话，**以不变应万变**，是架构应该追求的目标。