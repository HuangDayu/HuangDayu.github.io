---
title: Java新特性之函数式接口
date: 2019-04-09 15:03:29
categories:
- 后端开发 
tags:
- Java新特性
layout: post
published: true
comments: true
---

# 什么是函数式接口

&emsp;&emsp;Functional Interface，顾名思义就是函数式接口。它有以下特征：  
- 一个有且仅有一个抽象方法。
- 被`@FunctionalInterface`注解的接口声明是函数式接口，例如`java.lang.Runnable`,`java.util.concurrent.Callable`,`java.util.function.*`。
- **默认方法**和**静态方法**对函数式接口不影响。

<!-- more -->

# 为什么要函数式接口

&emsp;&emsp;为了让现有的功能与Lmabdas表达式有很好的兼容，不受非抽象函数的影响，和将接口（匿名内部类）隐式转为Lambda表达式。例如`java.lang.Runnable`接口。  

# 怎么样使用函数式接口

**Service.java**  

```java
@FunctionalInterface
public interface Service {
	/***
	 * 抽象方法
	 */
	public abstract void create();
	
	/***
	 * 静态方法：必须有方法体，实现着可以覆盖
	 * @param pid
	 */
	public static void delete(int pid) {};
	
	/***
	 * 默认方法：必须有方法体，实现着可以覆盖
	 */
	public default void update() {};
	
	/**
	 * 默认方法：必须有方法体，实现着可以覆盖
	 * @param pid
	 */
	public default void get(int pid) {};
}
```

**Server.java**  

```java
public class Server implements Service {

	private Service service;

	public Server(Service service) {
		this.service = service;
	};

	public void start() {
		this.service.create();
	};

	public void restart() {
		if (service != null) {
			this.service.create();
		} else {
			this.service.create();
		}
	};

	public void update() {
		this.service.update();
	};

	public void stop(int pid) {
		Service.delete(pid);
	}

	@Override
	public void create() {
		if (service != null) {
			service.create();
		}
	};
}
```

**Test.java**  

```java
public class Test {
	public static void main(String[] args) {
		// 使用函数接口的匿名内部类
		new Server(new Service() {
			@Override
			public void create() {
				System.out.println("start");
			}
		}).start();
		
		// 实际隐藏式转化为以下Lambda表达式
		new Server(() -> {
			System.out.println("restart");
		}).restart();
	}
}
```

# 参考文献

[Java 8 新特性](http://www.runoob.com/java/java8-new-features.html)  
[Java 8新特性终极指南](http://www.importnew.com/11908.html)  